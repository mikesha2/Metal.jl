
# Development

## Profiling

Profiling GPU code is harder than profiling Julia code executing on the CPU. Metal kernels
execute asynchronously and determining exactly what's executing on which piece of hardware
is difficult to determine at times (especially for M-series chips). Metal.jl and external
XCode tools help to empower the user to remedy these struggles.

## Timing

To accurately measure execution time in the presence of asynchronously-executing kernels,
do NOT use standard CPU timing tools unless the kernels are appropriately synchronized under
the CPU timing tool.

_@time and @elapsed macros coming soon..._

For robust measurements, it is advised to use the
[BenchmarkTools.jl](https://github.com/JuliaCI/BenchmarkTools.jl) package which goes to
great lengths to perform accurate measurements. Due to the asynchronous nature of GPUs, you
need to ensure the GPU is synchronized at the end of every sample, e.g. by calling
`synchronize()` or, even better, wrapping your code in `Metal.@sync`:

```julia
julia> a = MtlArray{Float32}(undef, (1024,1024,1024));

julia> @benchmark @metal threads=1024 grid=(1024*1024) dummy_kernel($a) # WRONG!
BenchmarkTools.Trial: 134 samples with 1 evaluation.
 Range (min … max):  30.500 μs … 71.998 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     40.739 ms              ┊ GC (median):    0.00%
 Time  (mean ± σ):   37.581 ms ± 13.976 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▄                                        ▁▅█▃▂
  █▄▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▆▁▄█████▇▆█▄▆▄▁▆▄▆▁▄▆ ▄
  30.5 μs      Histogram: log(frequency) by time      55.5 ms <

 Memory estimate: 1.55 KiB, allocs estimate: 43.

julia> @benchmark Metal.@sync @metal threads=1024 grid=(1024,1024) dummy_kernel($a) # RIGHT!
BenchmarkTools.Trial: 87 samples with 1 evaluation.
 Range (min … max):  41.200 ms … 341.584 ms  ┊ GC (min … max): 0.00% … 0.00%
 Time  (median):     49.048 ms               ┊ GC (median):    0.00%
 Time  (mean ± σ):   56.863 ms ±  33.773 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%

  ▆ ▆█▄ ▂
  █▆█████▄▄▆▄▆▃▆▄▁▆▄▄▁▁▆▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▃ ▁
  41.2 ms         Histogram: frequency by time          136 ms <

 Memory estimate: 1.68 KiB, allocs estimate: 46.
```

Without the synchronization provided by `Metal.@sync`, the first benchmark output reports
microsecond kernel times because BenchmarkTools only recorded the time to launch the kernel
rather than the actual kernel duration.

Note that the allocations as reported by BenchmarkTools are CPU allocations.


## Application Profiling

For profiling large applications, simple timings are insufficient. Instead, we want a
overview of how and when the GPU was active, to avoid times where the device was idle and/or
find which kernels needs optimization. As we cannot use the Julia profiler for this task,
profiling Metal.jl code involves using Apple's GPU Frame Capture tools.

To enable this, the `METAL_CAPTURE_ENABLED` environment variable must be set to 1 before
the start of the Julia session. Once enabled, profiling Metal code is completely triggered
from Julia itself (no need to start external programs beforehand).

This package exposes a simple `Metal.@profile` macro that handles starting and stopping
the tracing as well as accepting some configurable parameters.

```julia
julia> Metal.@profile my_metal_app();
```

For more finegrained control, use `startCapture` and `stopCapture`.

```julia
# Capture manager and capture descriptor initialization
...

julia> cpu_work()

julia> Metal.startCapture(cap_manager,cap_desc)

julia> finegrained_gpu_work()

julia> Metal.stopCapture()
```

For more examples of profiling, see the profiling script in the examples folder.

To view and interpret the profiled session, XCode tools are necessary. Simply open the
`.gputrace` folder generated by Metal.jl in XCode. See [Apple tutorials
](https://developer.apple.com/videos/play/wwdc2021/10157/) for more help on interpreting
the results.

## Troubleshooting

See the
[CUDA.jl troubleshooting page](https://cuda.juliagpu.org/stable/development/troubleshooting/)
as most of those tips are also applicable to Metal.jl. Note that `@device_code_metal` is the
 Metal equivalent of equivalent of CUDA.jl's `@device_code_ptx and @device_code_sass`.
